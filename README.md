 1. Ternary QuickSort
Время растёт примерно как N·logN, как и предсказывает теория.

Однако при почти отсортированных и обратно отсортированных входах может наблюдаться чуть большее время из-за неравномерного распределения "разделителей".

Число сравнений символов линейно растёт и соответствует N·logN.

 2. LCP MergeSort 
По времени очень стабилен и хорошо подходит для уже частично отсортированных строк, например, при "almost sorted".

Благодаря использованию общего префикса, количество сравнений символов заметно меньше, особенно на случайных и "почти отсортированных" данных.

Работает дольше, чем QuickSort на случайных данных, но выигрывает по символам.

 3. MSD Radix Sort
Время хорошо согласуется с линейной сложностью O(N·L).

На случайных данных особенно эффективен: время и число сравнений почти линейные.

При сильно похожих префиксах — может делать много рекурсий, что увеличивает накладные расходы.

4. MSD Radix Sort с fallback на QuickSort
На практике показывает лучшее время среди всех алгоритмов, особенно при малых или средних N.

Быстрее обычного MSD Radix, так как при малых подмассивах вместо неэффективной радикс-рекурсии применяется быстрый QuickSort.

Число сравнений — чуть больше, чем у чистого MSD, но значительно меньше, чем у MergeSort.

